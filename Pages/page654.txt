directly understood by the Central Processing Unit. For example, if you have a C++ source code file named prog.cpp
and you execute the compile command,
    g++ -Wall -ansi -o prog prog.cpp
There are 4 main stages involved in creating an executable file from the source file.
    1. The C++ the preprocessor takes a C++ source code file and deals with the headers(#include), macros(#define)
       and other preprocessor directives.
    2. The expanded C++ source code file produced by the C++ preprocessor is compiled into the assembly
       language for the platform.
    3. The assembler code generated by the compiler is assembled into the object code for the platform.
    4. The object code file produced by the assembler is linked together
             with the object code files for any library functions used to produce either a library or an executable file.
Preprocessing
The preprocessor handles the preprocessor directives, like #include and #define. It is agnostic of the syntax of C++,
which is why it must be used with care.
It works on one C++ source file at a time by replacing #include directives with the content of the respective files
(which is usually just declarations), doing replacement of macros (#define), and selecting different portions of text
depending of #if, #ifdef and #ifndef directives.
The preprocessor works on a stream of preprocessing tokens. Macro substitution is defined as replacing tokens
with other tokens (the operator ## enables merging two tokens when it make sense).
After all this, the preprocessor produces a single output that is a stream of tokens resulting from the
transformations described above. It also adds some special markers that tell the compiler where each line came
from so that it can use those to produce sensible error messages.
Some errors can be produced at this stage with clever use of the #if and #error directives.
By using below compiler flag, we can stop the process at preprocessing stage.
g++ -E prog.cpp
Compilation
The compilation step is performed on each output of the preprocessor. The compiler parses the pure C++ source
code (now without any preprocessor directives) and converts it into assembly code. Then invokes underlying back-
end(assembler in toolchain) that assembles that code into machine code producing actual binary file in some
format(ELF, COFF, a.out, ...). This object file contains the compiled code (in binary form) of the symbols defined in
the input. Symbols in object files are referred to by name.
Object files can refer to symbols that are not defined. This is the case when you use a declaration, and don't
provide a definition for it. The compiler doesn't mind this, and will happily produce the object file as long as the
source code is well-formed.
Compilers usually let you stop compilation at this point. This is very useful because with it you can compile each
source code file separately. The advantage this provides is that you don't need to recompile everything if you only
change a single file.